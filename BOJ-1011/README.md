## 문제 설명

공간이동 장치는 이동 거리를 급격하게 늘릴 경우 기계에 심각한 결함이 발생하는 단점이 있어서, <span style="color: orange;">**이전 작동시기에 k광년을 이동하였을 때는 k-1 , k 혹은 k+1 광년만을 다시 이동할 수 있다.**</span>

예를 들어, 이 장치를 처음 작동시킬 경우 -1 , 0 , 1 광년을 이론상 이동할 수 있으나 사실상 음수 혹은 0 거리만큼의 이동은 의미가 없으므로 1 광년을 이동할 수 있으며, 그 다음에는 0 , 1 , 2 광년을 이동할 수 있는 것이다. ( 여기서 다시 2광년을 이동한다면 다음 시기엔 1, 2, 3 광년을 이동할 수 있다. )

![](https://images.velog.io/images/soshin_dev/post/126a97dd-e819-4db3-9106-1c739021aff7/image.png)

김우현은 공간이동 장치 작동시의 에너지 소모가 크다는 점을 잘 알고 있기 때문에 <span style="color: orange;">**x지점에서 y지점을 향해 최소한의 작동 횟수로 이동하려 한다. 하지만 y지점에 도착해서도 공간 이동장치의 안전성을 위하여 y지점에 도착하기 바로 직전의 이동거리는 반드시 1광년으로 하려 한다.**</span>

김우현을 위해 <span style="color: orange;">**x지점부터 정확히 y지점으로 이동하는데 필요한 공간 이동 장치 작동 횟수의 최솟값을 구하는 프로그램을 작성**</span>하라.

---
### 입력
입력의 <span style="color: orange;">**첫 줄에는 테스트케이스의 개수 T**</span>가 주어진다. <span style="color: orange;">**각각의 테스트 케이스에 대해 현재 위치 x 와 목표 위치 y 가 정수로 주어지며, x는 항상 y보다 작은 값을 갖는다.**</span> (0 ≤ x < y < 2^31)

---
### 변수 설명
- **T**
  - 타입 : 정수
  - 저장 데이터 : 테스트 케이스의 개수를 입력받아 저장

- **x**
   - 타입 : 정수
   - 저장 데이터 : 현재 위치를 입력받아 저장
- **y**
   - 타입 : 정수
   - 저장 데이터 : 목표 위치를 입력받아 저장
- **d**
   - 타입 : 정수
   - 저장 데이터 : y와 x를 뺀 이동할 거리 값을 저장
- **speed**
   - 타입 : 정수
   - 저장 데이터 : 현재 속도
- **max_distance**
   - 타입 : 정수
   - 저장 데이터 : 현재 속도의 최대 거리 \[ 현재속도^2 ]
- **count_wrap**
   - 타입 : 정수
   - 저장 데이터 : 현 시점의 워프 횟수 \[ 2 * 현재속도 - 1]
   
---
### 풀이과정

| 횟수  | 이동한 거리 | 최대거리 | 워프한 횟수 | 최고속도 |
| :---: | :---: | :---: | :---: | :---: |
| 1 | 1 |1 | 1 | 1 |
| 2 | 121 | 4 | 3 | 2 |
| 3 | 12321 | 9 | 5 | 3 |
| 4 | 1234321 | 16 | 7 | 4 | 
| 5 | 123454321 | 25 | 9 | 5 |
| 6 | 12345654321 | 36 | 11 | 6 |
| S | 1..S..1 | S^2 | 2S - 1 | S |

위처럼 반복되는 과정을 잘 보면 구할 수 있는 공식을 찾을 수 있습니다.
최대거리는 최고속도를 제곱한 값 .
워프한 횟수는 최고속도에 2를 곱하고 1을 뺀 값으로 이걸 코드로 구현하면 아래와 같은 풀이를 통해
구현할 수 있습니다.

---


1. 테스트 케이스의 개수를 입력 받습니다. \[ t ]

2. 현재 위치와 목표 위치를 입력 받습니다. \[ x , y ]
3. 이동할 거리를 계산합니다. \[ d ]
4. 1부터 2^31 만큼 반복하며 목적지 까지 갈 수 있는 최대 속도를 찾습니다.

5-1. 만약 현재속도^2 이 이동할 거리 d 보다 크다면 현재 속도에서 1을 빼 줍니다. \[ speed ]

5-2. 그리고 현재 속도에서 갈 수 있는 최대 거리를 계산합니다. \[ max_distance ]

5-3. 현 시점까지 오는데 사용한 워프 횟수를 계산합니다. \[ count_warp ]

5-4. 그리고 현재 속도로 갈 수 있는 최대 거리를 이동할 거리에서 빼 남은거리를 계산합니다. \[ distance ]

5-5. 그리고 남은 거리를 최고 속도로 나눈 후 올림하여 워프 횟수에 카운트 해줍니다.

6-1. 만약 현재속도로 갈 수 있는 최대 거리와 이동할 거리가 같다면

6-2. 현재속도로 최대거리를 이동할 때 만큼 걸린 워프 횟수를 출력

**위 2번 ~ 6-2번 까지의 과정을 T 만큼 반복합니다.**

---
### 코드
```python
import sys
import math

T = int(sys.stdin.readline())  # 테스트 케이스의 개수를 입력

for i in range(T):
    x, y = map(int, sys.stdin.readline().split())  # 현재 위치 x 와 목표 위치 y 입력 [ x는 항상 y보다 작은 값 ]

    d = y - x  # 이동할 거리

    for s in range(1, pow(2, 31)):  # y의 최대 값이 2^31 이므로 2^31 만큼 반복
        if pow(s, 2) > d:  # 만약 현재 속도의 제곱 보다 거리가 크다면
            speed = s - 1  # 그 전 값을 저장
            max_distance = pow(speed, 2)  # 현재 속도의 최대 거리 ( 현재속도의 제곱 )
            count_warp = 2 * speed - 1  # 현 시점 워프 횟수 ( 2 * 현재속도 - 1 )
            distance = d - max_distance  # 남은거리

            count_warp += math.ceil(distance / speed)  # 남은 거리 이동 ( 남은 거리를 최고 속도로 나눈 값을 올림 )
            print(count_warp)
            break

        elif pow(s, 2) % d == 0:  # 현재 속도의 최대 거리가 이동할 거리와 같다면
            print(2 * s - 1)  # 이동할 거리까지 워프한 횟수 출력 ( 2 * 워프 횟수 - 1)
            break
```
